module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.29.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Address {
  id: ID!
  number: String
  prefix: String
  street: String
  type: String
  city: String
  state: String
  zip: String
  latitude: Float
  longitude: Float
}

type AddressConnection {
  pageInfo: PageInfo!
  edges: [AddressEdge]!
  aggregate: AggregateAddress!
}

input AddressCreateInput {
  number: String
  prefix: String
  street: String
  type: String
  city: String
  state: String
  zip: String
  latitude: Float
  longitude: Float
}

input AddressCreateOneInput {
  create: AddressCreateInput
  connect: AddressWhereUniqueInput
}

type AddressEdge {
  node: Address!
  cursor: String!
}

enum AddressOrderByInput {
  id_ASC
  id_DESC
  number_ASC
  number_DESC
  prefix_ASC
  prefix_DESC
  street_ASC
  street_DESC
  type_ASC
  type_DESC
  city_ASC
  city_DESC
  state_ASC
  state_DESC
  zip_ASC
  zip_DESC
  latitude_ASC
  latitude_DESC
  longitude_ASC
  longitude_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AddressPreviousValues {
  id: ID!
  number: String
  prefix: String
  street: String
  type: String
  city: String
  state: String
  zip: String
  latitude: Float
  longitude: Float
}

type AddressSubscriptionPayload {
  mutation: MutationType!
  node: Address
  updatedFields: [String!]
  previousValues: AddressPreviousValues
}

input AddressSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AddressWhereInput
  AND: [AddressSubscriptionWhereInput!]
  OR: [AddressSubscriptionWhereInput!]
  NOT: [AddressSubscriptionWhereInput!]
}

input AddressUpdateDataInput {
  number: String
  prefix: String
  street: String
  type: String
  city: String
  state: String
  zip: String
  latitude: Float
  longitude: Float
}

input AddressUpdateInput {
  number: String
  prefix: String
  street: String
  type: String
  city: String
  state: String
  zip: String
  latitude: Float
  longitude: Float
}

input AddressUpdateManyMutationInput {
  number: String
  prefix: String
  street: String
  type: String
  city: String
  state: String
  zip: String
  latitude: Float
  longitude: Float
}

input AddressUpdateOneRequiredInput {
  create: AddressCreateInput
  update: AddressUpdateDataInput
  upsert: AddressUpsertNestedInput
  connect: AddressWhereUniqueInput
}

input AddressUpsertNestedInput {
  update: AddressUpdateDataInput!
  create: AddressCreateInput!
}

input AddressWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  number: String
  number_not: String
  number_in: [String!]
  number_not_in: [String!]
  number_lt: String
  number_lte: String
  number_gt: String
  number_gte: String
  number_contains: String
  number_not_contains: String
  number_starts_with: String
  number_not_starts_with: String
  number_ends_with: String
  number_not_ends_with: String
  prefix: String
  prefix_not: String
  prefix_in: [String!]
  prefix_not_in: [String!]
  prefix_lt: String
  prefix_lte: String
  prefix_gt: String
  prefix_gte: String
  prefix_contains: String
  prefix_not_contains: String
  prefix_starts_with: String
  prefix_not_starts_with: String
  prefix_ends_with: String
  prefix_not_ends_with: String
  street: String
  street_not: String
  street_in: [String!]
  street_not_in: [String!]
  street_lt: String
  street_lte: String
  street_gt: String
  street_gte: String
  street_contains: String
  street_not_contains: String
  street_starts_with: String
  street_not_starts_with: String
  street_ends_with: String
  street_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  zip: String
  zip_not: String
  zip_in: [String!]
  zip_not_in: [String!]
  zip_lt: String
  zip_lte: String
  zip_gt: String
  zip_gte: String
  zip_contains: String
  zip_not_contains: String
  zip_starts_with: String
  zip_not_starts_with: String
  zip_ends_with: String
  zip_not_ends_with: String
  latitude: Float
  latitude_not: Float
  latitude_in: [Float!]
  latitude_not_in: [Float!]
  latitude_lt: Float
  latitude_lte: Float
  latitude_gt: Float
  latitude_gte: Float
  longitude: Float
  longitude_not: Float
  longitude_in: [Float!]
  longitude_not_in: [Float!]
  longitude_lt: Float
  longitude_lte: Float
  longitude_gt: Float
  longitude_gte: Float
  AND: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
}

input AddressWhereUniqueInput {
  id: ID
}

type AggregateAddress {
  count: Int!
}

type AggregateBuilding {
  count: Int!
}

type AggregateListing {
  count: Int!
}

type AggregateNeighborhood {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Building {
  id: ID!
  name: String!
}

type BuildingConnection {
  pageInfo: PageInfo!
  edges: [BuildingEdge]!
  aggregate: AggregateBuilding!
}

input BuildingCreateInput {
  name: String!
}

input BuildingCreateOneInput {
  create: BuildingCreateInput
  connect: BuildingWhereUniqueInput
}

type BuildingEdge {
  node: Building!
  cursor: String!
}

enum BuildingOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BuildingPreviousValues {
  id: ID!
  name: String!
}

type BuildingSubscriptionPayload {
  mutation: MutationType!
  node: Building
  updatedFields: [String!]
  previousValues: BuildingPreviousValues
}

input BuildingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BuildingWhereInput
  AND: [BuildingSubscriptionWhereInput!]
  OR: [BuildingSubscriptionWhereInput!]
  NOT: [BuildingSubscriptionWhereInput!]
}

input BuildingUpdateDataInput {
  name: String
}

input BuildingUpdateInput {
  name: String
}

input BuildingUpdateManyMutationInput {
  name: String
}

input BuildingUpdateOneInput {
  create: BuildingCreateInput
  update: BuildingUpdateDataInput
  upsert: BuildingUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: BuildingWhereUniqueInput
}

input BuildingUpsertNestedInput {
  update: BuildingUpdateDataInput!
  create: BuildingCreateInput!
}

input BuildingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [BuildingWhereInput!]
  OR: [BuildingWhereInput!]
  NOT: [BuildingWhereInput!]
}

input BuildingWhereUniqueInput {
  id: ID
  name: String
}

type Listing {
  id: ID!
  description: String
  price: Float
  propertyType: String
  yearBuilt: Int
  address: Address!
  building: Building
  neighborhood: Neighborhood
}

type ListingConnection {
  pageInfo: PageInfo!
  edges: [ListingEdge]!
  aggregate: AggregateListing!
}

input ListingCreateInput {
  description: String
  price: Float
  propertyType: String
  yearBuilt: Int
  address: AddressCreateOneInput!
  building: BuildingCreateOneInput
  neighborhood: NeighborhoodCreateOneInput
}

type ListingEdge {
  node: Listing!
  cursor: String!
}

enum ListingOrderByInput {
  id_ASC
  id_DESC
  description_ASC
  description_DESC
  price_ASC
  price_DESC
  propertyType_ASC
  propertyType_DESC
  yearBuilt_ASC
  yearBuilt_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ListingPreviousValues {
  id: ID!
  description: String
  price: Float
  propertyType: String
  yearBuilt: Int
}

type ListingSubscriptionPayload {
  mutation: MutationType!
  node: Listing
  updatedFields: [String!]
  previousValues: ListingPreviousValues
}

input ListingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ListingWhereInput
  AND: [ListingSubscriptionWhereInput!]
  OR: [ListingSubscriptionWhereInput!]
  NOT: [ListingSubscriptionWhereInput!]
}

input ListingUpdateInput {
  description: String
  price: Float
  propertyType: String
  yearBuilt: Int
  address: AddressUpdateOneRequiredInput
  building: BuildingUpdateOneInput
  neighborhood: NeighborhoodUpdateOneInput
}

input ListingUpdateManyMutationInput {
  description: String
  price: Float
  propertyType: String
  yearBuilt: Int
}

input ListingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  propertyType: String
  propertyType_not: String
  propertyType_in: [String!]
  propertyType_not_in: [String!]
  propertyType_lt: String
  propertyType_lte: String
  propertyType_gt: String
  propertyType_gte: String
  propertyType_contains: String
  propertyType_not_contains: String
  propertyType_starts_with: String
  propertyType_not_starts_with: String
  propertyType_ends_with: String
  propertyType_not_ends_with: String
  yearBuilt: Int
  yearBuilt_not: Int
  yearBuilt_in: [Int!]
  yearBuilt_not_in: [Int!]
  yearBuilt_lt: Int
  yearBuilt_lte: Int
  yearBuilt_gt: Int
  yearBuilt_gte: Int
  address: AddressWhereInput
  building: BuildingWhereInput
  neighborhood: NeighborhoodWhereInput
  AND: [ListingWhereInput!]
  OR: [ListingWhereInput!]
  NOT: [ListingWhereInput!]
}

input ListingWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAddress(data: AddressCreateInput!): Address!
  updateAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updateManyAddresses(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): BatchPayload!
  upsertAddress(where: AddressWhereUniqueInput!, create: AddressCreateInput!, update: AddressUpdateInput!): Address!
  deleteAddress(where: AddressWhereUniqueInput!): Address
  deleteManyAddresses(where: AddressWhereInput): BatchPayload!
  createBuilding(data: BuildingCreateInput!): Building!
  updateBuilding(data: BuildingUpdateInput!, where: BuildingWhereUniqueInput!): Building
  updateManyBuildings(data: BuildingUpdateManyMutationInput!, where: BuildingWhereInput): BatchPayload!
  upsertBuilding(where: BuildingWhereUniqueInput!, create: BuildingCreateInput!, update: BuildingUpdateInput!): Building!
  deleteBuilding(where: BuildingWhereUniqueInput!): Building
  deleteManyBuildings(where: BuildingWhereInput): BatchPayload!
  createListing(data: ListingCreateInput!): Listing!
  updateListing(data: ListingUpdateInput!, where: ListingWhereUniqueInput!): Listing
  updateManyListings(data: ListingUpdateManyMutationInput!, where: ListingWhereInput): BatchPayload!
  upsertListing(where: ListingWhereUniqueInput!, create: ListingCreateInput!, update: ListingUpdateInput!): Listing!
  deleteListing(where: ListingWhereUniqueInput!): Listing
  deleteManyListings(where: ListingWhereInput): BatchPayload!
  createNeighborhood(data: NeighborhoodCreateInput!): Neighborhood!
  updateNeighborhood(data: NeighborhoodUpdateInput!, where: NeighborhoodWhereUniqueInput!): Neighborhood
  updateManyNeighborhoods(data: NeighborhoodUpdateManyMutationInput!, where: NeighborhoodWhereInput): BatchPayload!
  upsertNeighborhood(where: NeighborhoodWhereUniqueInput!, create: NeighborhoodCreateInput!, update: NeighborhoodUpdateInput!): Neighborhood!
  deleteNeighborhood(where: NeighborhoodWhereUniqueInput!): Neighborhood
  deleteManyNeighborhoods(where: NeighborhoodWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type Neighborhood {
  id: ID!
  name: String!
}

type NeighborhoodConnection {
  pageInfo: PageInfo!
  edges: [NeighborhoodEdge]!
  aggregate: AggregateNeighborhood!
}

input NeighborhoodCreateInput {
  name: String!
}

input NeighborhoodCreateOneInput {
  create: NeighborhoodCreateInput
  connect: NeighborhoodWhereUniqueInput
}

type NeighborhoodEdge {
  node: Neighborhood!
  cursor: String!
}

enum NeighborhoodOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type NeighborhoodPreviousValues {
  id: ID!
  name: String!
}

type NeighborhoodSubscriptionPayload {
  mutation: MutationType!
  node: Neighborhood
  updatedFields: [String!]
  previousValues: NeighborhoodPreviousValues
}

input NeighborhoodSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NeighborhoodWhereInput
  AND: [NeighborhoodSubscriptionWhereInput!]
  OR: [NeighborhoodSubscriptionWhereInput!]
  NOT: [NeighborhoodSubscriptionWhereInput!]
}

input NeighborhoodUpdateDataInput {
  name: String
}

input NeighborhoodUpdateInput {
  name: String
}

input NeighborhoodUpdateManyMutationInput {
  name: String
}

input NeighborhoodUpdateOneInput {
  create: NeighborhoodCreateInput
  update: NeighborhoodUpdateDataInput
  upsert: NeighborhoodUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: NeighborhoodWhereUniqueInput
}

input NeighborhoodUpsertNestedInput {
  update: NeighborhoodUpdateDataInput!
  create: NeighborhoodCreateInput!
}

input NeighborhoodWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [NeighborhoodWhereInput!]
  OR: [NeighborhoodWhereInput!]
  NOT: [NeighborhoodWhereInput!]
}

input NeighborhoodWhereUniqueInput {
  id: ID
  name: String
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  address(where: AddressWhereUniqueInput!): Address
  addresses(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address]!
  addressesConnection(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AddressConnection!
  building(where: BuildingWhereUniqueInput!): Building
  buildings(where: BuildingWhereInput, orderBy: BuildingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Building]!
  buildingsConnection(where: BuildingWhereInput, orderBy: BuildingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BuildingConnection!
  listing(where: ListingWhereUniqueInput!): Listing
  listings(where: ListingWhereInput, orderBy: ListingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Listing]!
  listingsConnection(where: ListingWhereInput, orderBy: ListingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ListingConnection!
  neighborhood(where: NeighborhoodWhereUniqueInput!): Neighborhood
  neighborhoods(where: NeighborhoodWhereInput, orderBy: NeighborhoodOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Neighborhood]!
  neighborhoodsConnection(where: NeighborhoodWhereInput, orderBy: NeighborhoodOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NeighborhoodConnection!
  node(id: ID!): Node
}

type Subscription {
  address(where: AddressSubscriptionWhereInput): AddressSubscriptionPayload
  building(where: BuildingSubscriptionWhereInput): BuildingSubscriptionPayload
  listing(where: ListingSubscriptionWhereInput): ListingSubscriptionPayload
  neighborhood(where: NeighborhoodSubscriptionWhereInput): NeighborhoodSubscriptionPayload
}
`
      }
    