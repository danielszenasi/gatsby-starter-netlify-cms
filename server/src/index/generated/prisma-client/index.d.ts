// Code generated by Prisma (prisma@1.29.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  address: (where?: AddressWhereInput) => Promise<boolean>;
  building: (where?: BuildingWhereInput) => Promise<boolean>;
  listing: (where?: ListingWhereInput) => Promise<boolean>;
  neighborhood: (where?: NeighborhoodWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  address: (where: AddressWhereUniqueInput) => AddressPromise;
  addresses: (
    args?: {
      where?: AddressWhereInput;
      orderBy?: AddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Address>;
  addressesConnection: (
    args?: {
      where?: AddressWhereInput;
      orderBy?: AddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AddressConnectionPromise;
  building: (where: BuildingWhereUniqueInput) => BuildingPromise;
  buildings: (
    args?: {
      where?: BuildingWhereInput;
      orderBy?: BuildingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Building>;
  buildingsConnection: (
    args?: {
      where?: BuildingWhereInput;
      orderBy?: BuildingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BuildingConnectionPromise;
  listing: (where: ListingWhereUniqueInput) => ListingPromise;
  listings: (
    args?: {
      where?: ListingWhereInput;
      orderBy?: ListingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Listing>;
  listingsConnection: (
    args?: {
      where?: ListingWhereInput;
      orderBy?: ListingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ListingConnectionPromise;
  neighborhood: (where: NeighborhoodWhereUniqueInput) => NeighborhoodPromise;
  neighborhoods: (
    args?: {
      where?: NeighborhoodWhereInput;
      orderBy?: NeighborhoodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Neighborhood>;
  neighborhoodsConnection: (
    args?: {
      where?: NeighborhoodWhereInput;
      orderBy?: NeighborhoodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => NeighborhoodConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAddress: (data: AddressCreateInput) => AddressPromise;
  updateAddress: (
    args: { data: AddressUpdateInput; where: AddressWhereUniqueInput }
  ) => AddressPromise;
  updateManyAddresses: (
    args: { data: AddressUpdateManyMutationInput; where?: AddressWhereInput }
  ) => BatchPayloadPromise;
  upsertAddress: (
    args: {
      where: AddressWhereUniqueInput;
      create: AddressCreateInput;
      update: AddressUpdateInput;
    }
  ) => AddressPromise;
  deleteAddress: (where: AddressWhereUniqueInput) => AddressPromise;
  deleteManyAddresses: (where?: AddressWhereInput) => BatchPayloadPromise;
  createBuilding: (data: BuildingCreateInput) => BuildingPromise;
  updateBuilding: (
    args: { data: BuildingUpdateInput; where: BuildingWhereUniqueInput }
  ) => BuildingPromise;
  updateManyBuildings: (
    args: { data: BuildingUpdateManyMutationInput; where?: BuildingWhereInput }
  ) => BatchPayloadPromise;
  upsertBuilding: (
    args: {
      where: BuildingWhereUniqueInput;
      create: BuildingCreateInput;
      update: BuildingUpdateInput;
    }
  ) => BuildingPromise;
  deleteBuilding: (where: BuildingWhereUniqueInput) => BuildingPromise;
  deleteManyBuildings: (where?: BuildingWhereInput) => BatchPayloadPromise;
  createListing: (data: ListingCreateInput) => ListingPromise;
  updateListing: (
    args: { data: ListingUpdateInput; where: ListingWhereUniqueInput }
  ) => ListingPromise;
  updateManyListings: (
    args: { data: ListingUpdateManyMutationInput; where?: ListingWhereInput }
  ) => BatchPayloadPromise;
  upsertListing: (
    args: {
      where: ListingWhereUniqueInput;
      create: ListingCreateInput;
      update: ListingUpdateInput;
    }
  ) => ListingPromise;
  deleteListing: (where: ListingWhereUniqueInput) => ListingPromise;
  deleteManyListings: (where?: ListingWhereInput) => BatchPayloadPromise;
  createNeighborhood: (data: NeighborhoodCreateInput) => NeighborhoodPromise;
  updateNeighborhood: (
    args: { data: NeighborhoodUpdateInput; where: NeighborhoodWhereUniqueInput }
  ) => NeighborhoodPromise;
  updateManyNeighborhoods: (
    args: {
      data: NeighborhoodUpdateManyMutationInput;
      where?: NeighborhoodWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertNeighborhood: (
    args: {
      where: NeighborhoodWhereUniqueInput;
      create: NeighborhoodCreateInput;
      update: NeighborhoodUpdateInput;
    }
  ) => NeighborhoodPromise;
  deleteNeighborhood: (
    where: NeighborhoodWhereUniqueInput
  ) => NeighborhoodPromise;
  deleteManyNeighborhoods: (
    where?: NeighborhoodWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  address: (
    where?: AddressSubscriptionWhereInput
  ) => AddressSubscriptionPayloadSubscription;
  building: (
    where?: BuildingSubscriptionWhereInput
  ) => BuildingSubscriptionPayloadSubscription;
  listing: (
    where?: ListingSubscriptionWhereInput
  ) => ListingSubscriptionPayloadSubscription;
  neighborhood: (
    where?: NeighborhoodSubscriptionWhereInput
  ) => NeighborhoodSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AddressOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "number_ASC"
  | "number_DESC"
  | "prefix_ASC"
  | "prefix_DESC"
  | "street_ASC"
  | "street_DESC"
  | "unit_ASC"
  | "unit_DESC"
  | "type_ASC"
  | "type_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zip_ASC"
  | "zip_DESC"
  | "latitude_ASC"
  | "latitude_DESC"
  | "longitude_ASC"
  | "longitude_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BuildingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ListingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "price_ASC"
  | "price_DESC"
  | "propertyType_ASC"
  | "propertyType_DESC"
  | "yearBuilt_ASC"
  | "yearBuilt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NeighborhoodOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface AddressUpdateManyMutationInput {
  number?: String;
  prefix?: String;
  street?: String;
  unit?: String;
  type?: String;
  city?: String;
  state?: String;
  zip?: String;
  latitude?: Float;
  longitude?: Float;
}

export type AddressWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BuildingUpsertNestedInput {
  update: BuildingUpdateDataInput;
  create: BuildingCreateInput;
}

export interface BuildingUpdateManyMutationInput {
  name?: String;
}

export interface BuildingUpdateDataInput {
  name?: String;
}

export interface BuildingCreateInput {
  name: String;
}

export interface BuildingUpdateOneInput {
  create?: BuildingCreateInput;
  update?: BuildingUpdateDataInput;
  upsert?: BuildingUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BuildingWhereUniqueInput;
}

export interface ListingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ListingWhereInput;
  AND?: ListingSubscriptionWhereInput[] | ListingSubscriptionWhereInput;
  OR?: ListingSubscriptionWhereInput[] | ListingSubscriptionWhereInput;
  NOT?: ListingSubscriptionWhereInput[] | ListingSubscriptionWhereInput;
}

export interface AddressUpsertNestedInput {
  update: AddressUpdateDataInput;
  create: AddressCreateInput;
}

export interface AddressSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AddressWhereInput;
  AND?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
  OR?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
  NOT?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
}

export type NeighborhoodWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface NeighborhoodUpdateManyMutationInput {
  name?: String;
}

export interface AddressUpdateDataInput {
  number?: String;
  prefix?: String;
  street?: String;
  unit?: String;
  type?: String;
  city?: String;
  state?: String;
  zip?: String;
  latitude?: Float;
  longitude?: Float;
}

export interface AddressWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  number?: String;
  number_not?: String;
  number_in?: String[] | String;
  number_not_in?: String[] | String;
  number_lt?: String;
  number_lte?: String;
  number_gt?: String;
  number_gte?: String;
  number_contains?: String;
  number_not_contains?: String;
  number_starts_with?: String;
  number_not_starts_with?: String;
  number_ends_with?: String;
  number_not_ends_with?: String;
  prefix?: String;
  prefix_not?: String;
  prefix_in?: String[] | String;
  prefix_not_in?: String[] | String;
  prefix_lt?: String;
  prefix_lte?: String;
  prefix_gt?: String;
  prefix_gte?: String;
  prefix_contains?: String;
  prefix_not_contains?: String;
  prefix_starts_with?: String;
  prefix_not_starts_with?: String;
  prefix_ends_with?: String;
  prefix_not_ends_with?: String;
  street?: String;
  street_not?: String;
  street_in?: String[] | String;
  street_not_in?: String[] | String;
  street_lt?: String;
  street_lte?: String;
  street_gt?: String;
  street_gte?: String;
  street_contains?: String;
  street_not_contains?: String;
  street_starts_with?: String;
  street_not_starts_with?: String;
  street_ends_with?: String;
  street_not_ends_with?: String;
  unit?: String;
  unit_not?: String;
  unit_in?: String[] | String;
  unit_not_in?: String[] | String;
  unit_lt?: String;
  unit_lte?: String;
  unit_gt?: String;
  unit_gte?: String;
  unit_contains?: String;
  unit_not_contains?: String;
  unit_starts_with?: String;
  unit_not_starts_with?: String;
  unit_ends_with?: String;
  unit_not_ends_with?: String;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  state?: String;
  state_not?: String;
  state_in?: String[] | String;
  state_not_in?: String[] | String;
  state_lt?: String;
  state_lte?: String;
  state_gt?: String;
  state_gte?: String;
  state_contains?: String;
  state_not_contains?: String;
  state_starts_with?: String;
  state_not_starts_with?: String;
  state_ends_with?: String;
  state_not_ends_with?: String;
  zip?: String;
  zip_not?: String;
  zip_in?: String[] | String;
  zip_not_in?: String[] | String;
  zip_lt?: String;
  zip_lte?: String;
  zip_gt?: String;
  zip_gte?: String;
  zip_contains?: String;
  zip_not_contains?: String;
  zip_starts_with?: String;
  zip_not_starts_with?: String;
  zip_ends_with?: String;
  zip_not_ends_with?: String;
  latitude?: Float;
  latitude_not?: Float;
  latitude_in?: Float[] | Float;
  latitude_not_in?: Float[] | Float;
  latitude_lt?: Float;
  latitude_lte?: Float;
  latitude_gt?: Float;
  latitude_gte?: Float;
  longitude?: Float;
  longitude_not?: Float;
  longitude_in?: Float[] | Float;
  longitude_not_in?: Float[] | Float;
  longitude_lt?: Float;
  longitude_lte?: Float;
  longitude_gt?: Float;
  longitude_gte?: Float;
  AND?: AddressWhereInput[] | AddressWhereInput;
  OR?: AddressWhereInput[] | AddressWhereInput;
  NOT?: AddressWhereInput[] | AddressWhereInput;
}

export interface AddressUpdateOneRequiredInput {
  create?: AddressCreateInput;
  update?: AddressUpdateDataInput;
  upsert?: AddressUpsertNestedInput;
  connect?: AddressWhereUniqueInput;
}

export interface ListingUpdateManyMutationInput {
  description?: String;
  price?: Float;
  propertyType?: String;
  yearBuilt?: Int;
}

export interface ListingUpdateInput {
  description?: String;
  price?: Float;
  propertyType?: String;
  yearBuilt?: Int;
  address?: AddressUpdateOneRequiredInput;
  building?: BuildingUpdateOneInput;
  neighborhood?: NeighborhoodUpdateOneInput;
}

export type ListingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface NeighborhoodCreateInput {
  name: String;
}

export interface NeighborhoodUpdateOneInput {
  create?: NeighborhoodCreateInput;
  update?: NeighborhoodUpdateDataInput;
  upsert?: NeighborhoodUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: NeighborhoodWhereUniqueInput;
}

export interface NeighborhoodWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: NeighborhoodWhereInput[] | NeighborhoodWhereInput;
  OR?: NeighborhoodWhereInput[] | NeighborhoodWhereInput;
  NOT?: NeighborhoodWhereInput[] | NeighborhoodWhereInput;
}

export interface BuildingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BuildingWhereInput;
  AND?: BuildingSubscriptionWhereInput[] | BuildingSubscriptionWhereInput;
  OR?: BuildingSubscriptionWhereInput[] | BuildingSubscriptionWhereInput;
  NOT?: BuildingSubscriptionWhereInput[] | BuildingSubscriptionWhereInput;
}

export interface AddressCreateInput {
  number?: String;
  prefix?: String;
  street?: String;
  unit?: String;
  type?: String;
  city?: String;
  state?: String;
  zip?: String;
  latitude?: Float;
  longitude?: Float;
}

export interface BuildingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: BuildingWhereInput[] | BuildingWhereInput;
  OR?: BuildingWhereInput[] | BuildingWhereInput;
  NOT?: BuildingWhereInput[] | BuildingWhereInput;
}

export interface AddressUpdateInput {
  number?: String;
  prefix?: String;
  street?: String;
  unit?: String;
  type?: String;
  city?: String;
  state?: String;
  zip?: String;
  latitude?: Float;
  longitude?: Float;
}

export interface NeighborhoodUpsertNestedInput {
  update: NeighborhoodUpdateDataInput;
  create: NeighborhoodCreateInput;
}

export interface NeighborhoodCreateOneInput {
  create?: NeighborhoodCreateInput;
  connect?: NeighborhoodWhereUniqueInput;
}

export interface ListingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  propertyType?: String;
  propertyType_not?: String;
  propertyType_in?: String[] | String;
  propertyType_not_in?: String[] | String;
  propertyType_lt?: String;
  propertyType_lte?: String;
  propertyType_gt?: String;
  propertyType_gte?: String;
  propertyType_contains?: String;
  propertyType_not_contains?: String;
  propertyType_starts_with?: String;
  propertyType_not_starts_with?: String;
  propertyType_ends_with?: String;
  propertyType_not_ends_with?: String;
  yearBuilt?: Int;
  yearBuilt_not?: Int;
  yearBuilt_in?: Int[] | Int;
  yearBuilt_not_in?: Int[] | Int;
  yearBuilt_lt?: Int;
  yearBuilt_lte?: Int;
  yearBuilt_gt?: Int;
  yearBuilt_gte?: Int;
  address?: AddressWhereInput;
  building?: BuildingWhereInput;
  neighborhood?: NeighborhoodWhereInput;
  AND?: ListingWhereInput[] | ListingWhereInput;
  OR?: ListingWhereInput[] | ListingWhereInput;
  NOT?: ListingWhereInput[] | ListingWhereInput;
}

export interface BuildingUpdateInput {
  name?: String;
}

export interface ListingCreateInput {
  description?: String;
  price?: Float;
  propertyType?: String;
  yearBuilt?: Int;
  address: AddressCreateOneInput;
  building?: BuildingCreateOneInput;
  neighborhood?: NeighborhoodCreateOneInput;
}

export interface AddressCreateOneInput {
  create?: AddressCreateInput;
  connect?: AddressWhereUniqueInput;
}

export interface BuildingCreateOneInput {
  create?: BuildingCreateInput;
  connect?: BuildingWhereUniqueInput;
}

export interface NeighborhoodSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: NeighborhoodWhereInput;
  AND?:
    | NeighborhoodSubscriptionWhereInput[]
    | NeighborhoodSubscriptionWhereInput;
  OR?:
    | NeighborhoodSubscriptionWhereInput[]
    | NeighborhoodSubscriptionWhereInput;
  NOT?:
    | NeighborhoodSubscriptionWhereInput[]
    | NeighborhoodSubscriptionWhereInput;
}

export interface NeighborhoodUpdateDataInput {
  name?: String;
}

export interface NeighborhoodUpdateInput {
  name?: String;
}

export type BuildingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface NeighborhoodPreviousValues {
  id: ID_Output;
  name: String;
}

export interface NeighborhoodPreviousValuesPromise
  extends Promise<NeighborhoodPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface NeighborhoodPreviousValuesSubscription
  extends Promise<AsyncIterator<NeighborhoodPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface BuildingEdge {
  node: Building;
  cursor: String;
}

export interface BuildingEdgePromise
  extends Promise<BuildingEdge>,
    Fragmentable {
  node: <T = BuildingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BuildingEdgeSubscription
  extends Promise<AsyncIterator<BuildingEdge>>,
    Fragmentable {
  node: <T = BuildingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AddressConnection {
  pageInfo: PageInfo;
  edges: AddressEdge[];
}

export interface AddressConnectionPromise
  extends Promise<AddressConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AddressEdge>>() => T;
  aggregate: <T = AggregateAddressPromise>() => T;
}

export interface AddressConnectionSubscription
  extends Promise<AsyncIterator<AddressConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AddressEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAddressSubscription>() => T;
}

export interface BuildingConnection {
  pageInfo: PageInfo;
  edges: BuildingEdge[];
}

export interface BuildingConnectionPromise
  extends Promise<BuildingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BuildingEdge>>() => T;
  aggregate: <T = AggregateBuildingPromise>() => T;
}

export interface BuildingConnectionSubscription
  extends Promise<AsyncIterator<BuildingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BuildingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBuildingSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Building {
  id: ID_Output;
  name: String;
}

export interface BuildingPromise extends Promise<Building>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface BuildingSubscription
  extends Promise<AsyncIterator<Building>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNeighborhood {
  count: Int;
}

export interface AggregateNeighborhoodPromise
  extends Promise<AggregateNeighborhood>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNeighborhoodSubscription
  extends Promise<AsyncIterator<AggregateNeighborhood>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateAddress {
  count: Int;
}

export interface AggregateAddressPromise
  extends Promise<AggregateAddress>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAddressSubscription
  extends Promise<AsyncIterator<AggregateAddress>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NeighborhoodConnection {
  pageInfo: PageInfo;
  edges: NeighborhoodEdge[];
}

export interface NeighborhoodConnectionPromise
  extends Promise<NeighborhoodConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NeighborhoodEdge>>() => T;
  aggregate: <T = AggregateNeighborhoodPromise>() => T;
}

export interface NeighborhoodConnectionSubscription
  extends Promise<AsyncIterator<NeighborhoodConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NeighborhoodEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNeighborhoodSubscription>() => T;
}

export interface Address {
  id: ID_Output;
  number?: String;
  prefix?: String;
  street?: String;
  unit?: String;
  type?: String;
  city?: String;
  state?: String;
  zip?: String;
  latitude?: Float;
  longitude?: Float;
}

export interface AddressPromise extends Promise<Address>, Fragmentable {
  id: () => Promise<ID_Output>;
  number: () => Promise<String>;
  prefix: () => Promise<String>;
  street: () => Promise<String>;
  unit: () => Promise<String>;
  type: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<String>;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
}

export interface AddressSubscription
  extends Promise<AsyncIterator<Address>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  number: () => Promise<AsyncIterator<String>>;
  prefix: () => Promise<AsyncIterator<String>>;
  street: () => Promise<AsyncIterator<String>>;
  unit: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
  latitude: () => Promise<AsyncIterator<Float>>;
  longitude: () => Promise<AsyncIterator<Float>>;
}

export interface AggregateListing {
  count: Int;
}

export interface AggregateListingPromise
  extends Promise<AggregateListing>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateListingSubscription
  extends Promise<AsyncIterator<AggregateListing>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AddressSubscriptionPayload {
  mutation: MutationType;
  node: Address;
  updatedFields: String[];
  previousValues: AddressPreviousValues;
}

export interface AddressSubscriptionPayloadPromise
  extends Promise<AddressSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AddressPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AddressPreviousValuesPromise>() => T;
}

export interface AddressSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AddressSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AddressSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AddressPreviousValuesSubscription>() => T;
}

export interface ListingConnection {
  pageInfo: PageInfo;
  edges: ListingEdge[];
}

export interface ListingConnectionPromise
  extends Promise<ListingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ListingEdge>>() => T;
  aggregate: <T = AggregateListingPromise>() => T;
}

export interface ListingConnectionSubscription
  extends Promise<AsyncIterator<ListingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ListingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateListingSubscription>() => T;
}

export interface AddressPreviousValues {
  id: ID_Output;
  number?: String;
  prefix?: String;
  street?: String;
  unit?: String;
  type?: String;
  city?: String;
  state?: String;
  zip?: String;
  latitude?: Float;
  longitude?: Float;
}

export interface AddressPreviousValuesPromise
  extends Promise<AddressPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  number: () => Promise<String>;
  prefix: () => Promise<String>;
  street: () => Promise<String>;
  unit: () => Promise<String>;
  type: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zip: () => Promise<String>;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
}

export interface AddressPreviousValuesSubscription
  extends Promise<AsyncIterator<AddressPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  number: () => Promise<AsyncIterator<String>>;
  prefix: () => Promise<AsyncIterator<String>>;
  street: () => Promise<AsyncIterator<String>>;
  unit: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zip: () => Promise<AsyncIterator<String>>;
  latitude: () => Promise<AsyncIterator<Float>>;
  longitude: () => Promise<AsyncIterator<Float>>;
}

export interface Neighborhood {
  id: ID_Output;
  name: String;
}

export interface NeighborhoodPromise
  extends Promise<Neighborhood>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface NeighborhoodSubscription
  extends Promise<AsyncIterator<Neighborhood>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AddressEdge {
  node: Address;
  cursor: String;
}

export interface AddressEdgePromise extends Promise<AddressEdge>, Fragmentable {
  node: <T = AddressPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AddressEdgeSubscription
  extends Promise<AsyncIterator<AddressEdge>>,
    Fragmentable {
  node: <T = AddressSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBuilding {
  count: Int;
}

export interface AggregateBuildingPromise
  extends Promise<AggregateBuilding>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBuildingSubscription
  extends Promise<AsyncIterator<AggregateBuilding>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ListingSubscriptionPayload {
  mutation: MutationType;
  node: Listing;
  updatedFields: String[];
  previousValues: ListingPreviousValues;
}

export interface ListingSubscriptionPayloadPromise
  extends Promise<ListingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ListingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ListingPreviousValuesPromise>() => T;
}

export interface ListingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ListingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ListingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ListingPreviousValuesSubscription>() => T;
}

export interface BuildingPreviousValues {
  id: ID_Output;
  name: String;
}

export interface BuildingPreviousValuesPromise
  extends Promise<BuildingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface BuildingPreviousValuesSubscription
  extends Promise<AsyncIterator<BuildingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface NeighborhoodEdge {
  node: Neighborhood;
  cursor: String;
}

export interface NeighborhoodEdgePromise
  extends Promise<NeighborhoodEdge>,
    Fragmentable {
  node: <T = NeighborhoodPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NeighborhoodEdgeSubscription
  extends Promise<AsyncIterator<NeighborhoodEdge>>,
    Fragmentable {
  node: <T = NeighborhoodSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ListingPreviousValues {
  id: ID_Output;
  description?: String;
  price?: Float;
  propertyType?: String;
  yearBuilt?: Int;
}

export interface ListingPreviousValuesPromise
  extends Promise<ListingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  price: () => Promise<Float>;
  propertyType: () => Promise<String>;
  yearBuilt: () => Promise<Int>;
}

export interface ListingPreviousValuesSubscription
  extends Promise<AsyncIterator<ListingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  propertyType: () => Promise<AsyncIterator<String>>;
  yearBuilt: () => Promise<AsyncIterator<Int>>;
}

export interface Listing {
  id: ID_Output;
  description?: String;
  price?: Float;
  propertyType?: String;
  yearBuilt?: Int;
}

export interface ListingPromise extends Promise<Listing>, Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  price: () => Promise<Float>;
  propertyType: () => Promise<String>;
  yearBuilt: () => Promise<Int>;
  address: <T = AddressPromise>() => T;
  building: <T = BuildingPromise>() => T;
  neighborhood: <T = NeighborhoodPromise>() => T;
}

export interface ListingSubscription
  extends Promise<AsyncIterator<Listing>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  propertyType: () => Promise<AsyncIterator<String>>;
  yearBuilt: () => Promise<AsyncIterator<Int>>;
  address: <T = AddressSubscription>() => T;
  building: <T = BuildingSubscription>() => T;
  neighborhood: <T = NeighborhoodSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ListingEdge {
  node: Listing;
  cursor: String;
}

export interface ListingEdgePromise extends Promise<ListingEdge>, Fragmentable {
  node: <T = ListingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ListingEdgeSubscription
  extends Promise<AsyncIterator<ListingEdge>>,
    Fragmentable {
  node: <T = ListingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NeighborhoodSubscriptionPayload {
  mutation: MutationType;
  node: Neighborhood;
  updatedFields: String[];
  previousValues: NeighborhoodPreviousValues;
}

export interface NeighborhoodSubscriptionPayloadPromise
  extends Promise<NeighborhoodSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NeighborhoodPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NeighborhoodPreviousValuesPromise>() => T;
}

export interface NeighborhoodSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NeighborhoodSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NeighborhoodSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NeighborhoodPreviousValuesSubscription>() => T;
}

export interface BuildingSubscriptionPayload {
  mutation: MutationType;
  node: Building;
  updatedFields: String[];
  previousValues: BuildingPreviousValues;
}

export interface BuildingSubscriptionPayloadPromise
  extends Promise<BuildingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BuildingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BuildingPreviousValuesPromise>() => T;
}

export interface BuildingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BuildingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BuildingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BuildingPreviousValuesSubscription>() => T;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Address",
    embedded: false
  },
  {
    name: "Listing",
    embedded: false
  },
  {
    name: "Building",
    embedded: false
  },
  {
    name: "Neighborhood",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
